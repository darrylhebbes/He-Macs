#+TITLE: He-Macs
#+SUBTITLE: Henry's GNU Emacs literate config
#+AUTHOR: hmatheisen
#+LANGUAGE: en

#+BEGIN_QUOTE
I have the power! - [[https://www.youtube.com/watch?v=4zIoElk3r2c][He-Man]]
#+END_QUOTE

* Table of Contents :TOC:noexport:
- [[#what-is-this][What is this?]]
  - [[#abstract][Abstract]]
  - [[#why-though][Why though?]]
  - [[#installation][Installation]]
- [[#creating-the-files][Creating the files]]
  - [[#files-to-ignore][Files to ignore]]
  - [[#initel][=init.el=]]
- [[#initialization][Initialization]]
  - [[#custom-constantsvariables][Custom constants/variables]]
  - [[#add-package-archives][Add package archives]]
  - [[#install-use-package][Install use-package]]
  - [[#require-personal-packages][Require personal packages]]
- [[#global-settings][Global settings]]
  - [[#settings-without-packages][Settings without packages]]
  - [[#custom][Custom]]
  - [[#terminal-binary][Terminal binary]]
  - [[#window][Window]]
  - [[#windmove][WindMove]]
  - [[#y-or-n--yes-or-no][Y or N > Yes or No]]
  - [[#time-mode][Time mode]]
  - [[#simple][Simple]]
  - [[#display-battery-level][Display battery level]]
  - [[#line-numbers][Line numbers]]
  - [[#files][Files]]
  - [[#frame-settings][Frame settings]]
  - [[#winner-mode][Winner mode]]
  - [[#modern-region-behavior][Modern region behavior]]
  - [[#no-scroll-bar][No scroll bar]]
  - [[#matching-parentheses][Matching Parentheses]]
  - [[#ediff][Ediff]]
  - [[#auto-pair][Auto-pair]]
  - [[#use-ibuffer][Use ibuffer]]
  - [[#compile][Compile]]
  - [[#info][Info]]
  - [[#js][JS]]
- [[#third-party-packages][Third-party Packages]]
  - [[#themes][Themes]]
  - [[#diminish][Diminish]]
  - [[#ivy][Ivy]]
  - [[#code-completion][Code Completion]]
  - [[#org-mode][Org Mode]]
  - [[#magit][Magit]]
  - [[#flycheck][Flycheck]]
  - [[#projectile][Projectile]]
  - [[#neotree][Neotree]]
  - [[#which-key][Which key]]
  - [[#undo-tree][Undo tree]]
  - [[#all-the-icons][All the icons]]
  - [[#dashboard][Dashboard]]
  - [[#snippets][Snippets]]
  - [[#clojure][Clojure]]
  - [[#typescript][Typescript]]
  - [[#docker][Docker]]
  - [[#yaml][YAML]]
  - [[#go][Go]]
- [[#personal-packages][Personal Packages]]
  - [[#new-term][New Term]]
  - [[#theme-switcher][Theme Switcher]]
- [[#closing-files][Closing files]]
  - [[#initel-1][=init.el=]]

* What is this?
  
Let's forget about this dumb play on words between my name and a
cartoon from the 80's and actually explain what this file is.

** Abstract

This is my attempt at writing a literate Emacs configuration using
Org, a "simple outliner for note-taking and list management" that
actually does way more.  Although this configuration is for myself and
is opinionated, anyone is free to watch, copy or use its content.

** Why though?

Fame?  No.  Fun?  Maybe.  Having your whole configuration in a single
file might be a little messy but a literate file such as this one
looks like a neat idea to organize and document my dear Emacs
configuration.  Of course the file will eventually be gigantic but Org
Mode makes it easy to manage.  Documentation is also a huge plus since
I usually get lost in the maze of Emacs Lisp that is my current
config.

** Installation

All you need to do is to clone this repository, I added the tangled
file to git so the =init.el= is already here.  Since I use submodules,
you need to clone recursively this repository.

#+BEGIN_SRC bash
# Maybe backup you files first
mv ~/.emacs.d ~/.emacs.bak
#+END_SRC

#+BEGIN_SRC bash
git clone --recursive https://github.com/hmatheisen/.emacs.d.git ~/.emacs.d
#+END_SRC

* Creating the files

** Files to ignore

This is my =.gitignore= file.

#+BEGIN_SRC text :tangle .gitignore
.backups/
.cache/
.lsp-session-v1
auto-save-list/
bookmarks
custom.el
elpa/
games/
ido.last
nov-places
projectile-bookmarks.eld
projectile.cache
recentf
transient/
#+END_SRC

** =init.el=

#+BEGIN_SRC emacs-lisp :tangle init.el
;;; init.el --- Emacs Init File

;;; Commentary:
;;; My Emacs Init File
;;; This file is generted by `config.org', since there are no comments in here,
;;; you should go have a look there for more information.

;;; Code:
#+END_SRC

* Initialization

These are the first few lines of code that start it all.  They go into
=init.el= and will be added to git since they are needed to install
Org on a new system and therefore read this file ton install the rest
of the configuration.  I will keep maintaining =init.el= in this file
since =org-babel-tangle= just rewrites the file if new modifications
are made.

** Custom constants/variables

#+BEGIN_SRC emacs-lisp :tangle init.el
(defconst *is-a-mac* (eq system-type 'darwin)
  "Check whether system is mac.")
#+END_SRC

** Add package archives
<
#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'package)
(add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/"))
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
(setq package-enable-at-startup nil)
(package-initialize)
#+END_SRC

** Install use-package

=use-package= is quite handy and will allow us to require and install
packages in a tidy way, we install it here and make sure it installs
the packages we want by default.

#+BEGIN_SRC emacs-lisp :tangle init.el
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-and-compile
  (require 'use-package-ensure)
  (setq use-package-always-ensure t))
#+END_SRC

** Require personal packages

Those packages are installed with git submodules.  They are isolated
packages written by me so they don't need any description here.  We
just add them to load path so that =use-package= can do the job later.

#+BEGIN_SRC emacs-lisp :tangle init.el
(add-to-list 'load-path "~/.emacs.d/site-lisp/theme-switcher")
(add-to-list 'load-path "~/.emacs.d/site-lisp/new-term")
#+END_SRC

* Global settings

These are settings to change the look/behavior of Emacs using only
native options.  I regroup them by their package using =use-package=.
There is nothing really fancy happening here, just cleaning up the UI
and setting some variables.  Since I always ensure packages by
default, I make sure to add =:ensure nil= on native packages so
=use-package= does not try to look for them in MELPA.

** Settings without packages

These are settings defined in the C source code of emacs so they are
not related to any Lisp packages, let's put them in a package called
=emacs=.

*** Macos

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emacs
  :ensure nil
  :config
  ;; Avoid a few issues on MacOS
  (when *is-a-mac*
    (setq mac-option-modifier nil
          mac-command-modifier 'meta
          select-enable-clipboard t))
  ;; Title Bar Settings
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
  (setq ns-use-proxy-icon  nil)
  (setq frame-title-format nil))
#+END_SRC

*** UI/UX

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emacs
  :ensure nil
  :config
  ;; Remove Toolbar
  (tool-bar-mode -1)
  ;; Disable menu bar
  (menu-bar-mode -1)
  ;; Enable downcase/upcase region
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  ;; Trash can support
  (setq delete-by-moving-to-trash t)
  ;; Indent using spaces
  (setq-default indent-tabs-mode nil)
  ;; Set tabs to 2
  (setq-default tab-width 2)
  ;; Make that damn bell shut up
  (setq ring-bell-function 'ignore)
  ;; Default truncate lines
  (setq-default truncate-lines t))
#+END_SRC

*** Garbage collection

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emacs
  :ensure nil
  :preface
  (defun garbage-collect-defer ()
    "Defer garbage collection."
    (setq gc-cons-threshold most-positive-fixnum
          gc-cons-percentage 0.6))
  (defun garbage-collect-restore ()
    "Return garbage collection to slightly higher parameter."
    (setq gc-cons-threshold 100000000
          gc-cons-percentage 0.1))
  :config
  ;; Set garbage collection
  (garbage-collect-defer)
  (add-hook 'emacs-startup-hook #'garbage-collect-restore)
  (add-hook 'minibuffer-setup-hook #'garbage-collect-defer)
  (add-hook 'minibuffer-exit-hook #'garbage-collect-restore))
#+END_SRC

*** Path

#+BEGIN_SRC emacs-lisp :tangle init.el
;; Resolve path issues
(use-package emacs
  :preface
  (defun add-to-path (path)
    "Add a path to `exec-path' and Emacs \"PATH\" variable."
    (add-to-list 'exec-path (substring path 1))
    (setenv "PATH" (concat (getenv "PATH") path)))
  :ensure nil
  :config
  ;; Add useful path to exec-path and PATH
  (add-to-path ":/usr/local/bin")
  (add-to-path ":/Library/TeX/texbin")
  (add-to-path ":~/go/bin"))
#+END_SRC

*** UTF-8

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emacs
  :ensure nil
  :config
  ;; Set utf8 everywhere
  (prefer-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8))
#+END_SRC

*** Half scroll

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emacs
  :ensure nil
  :preface
  (defun zz-scroll-half-page (direction)
    "Scrolls half page up if `direction' is non-nil, otherwise will scroll half page down."
    (let ((opos (cdr (nth 6 (posn-at-point)))))
      ;; opos = original position line relative to window
      (move-to-window-line nil)  ;; Move cursor to middle line
      (if direction
          (recenter-top-bottom -1)  ;; Current line becomes last
        (recenter-top-bottom 0))  ;; Current line becomes first
      (move-to-window-line opos)))  ;; Restore cursor/point position

  (defun zz-scroll-half-page-down ()
    "Scrolls exactly half page down keeping cursor/point position."
    (interactive)
    (zz-scroll-half-page nil))

  (defun zz-scroll-half-page-up ()
    "Scrolls exactly half page up keeping cursor/point position."
    (interactive)
    (zz-scroll-half-page t))
  :config
  (global-set-key (kbd "C-v") 'zz-scroll-half-page-down)
  (global-set-key (kbd "M-v") 'zz-scroll-half-page-up))
#+END_SRC

** Custom

The custom file is not really useful here since every parameter is set
using elisp.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package custom
  :ensure nil
  :config 
  (setq custom-safe-themes t)
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory)))
#+END_SRC

** Terminal binary

On MacOS, I use a new version of =bash= installed with =brew= since I
can't update the default one. Therefore the path is changed to
=/usr/local/bin/bash=.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package term
  :ensure nil
  :config
  (if *is-a-mac*
      (setq explicit-shell-file-name "/usr/local/bin/bash")
    (setq explicit-shell-file-name "/bin/bash")))
#+END_SRC

** Window

Change keybindings to resize window so I can just keep pressing them.
Also I change the default keybindings to go to another window since
=C-x o= is a little too long in my opinion.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package "window"
  :ensure nil
  :preface
  (defun my-split-window-right ()
    "Splits window on the right then focus on that window"
    (interactive)
    (split-window-right)
    (other-window 1))
  (defun my-split-window-below ()
    "Splits windmow below then focus on that window"
    (interactive)
    (split-window-below)
    (other-window 1))
  :config
  ;; Resizing
  (global-set-key (kbd "M--") 'shrink-window)
  (global-set-key (kbd "M-+") 'enlarge-window)
  (global-set-key (kbd "C--") 'shrink-window-horizontally)
  (global-set-key (kbd "C-+") 'enlarge-window-horizontally)
  ;; Other window (windmove is also setup but this can be easier)
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "M-O") '(lambda ()
                                 (interactive)
                                 (other-window -1)))
  ;; scroll window up/down by one line
  (global-set-key (kbd "M-n") '(lambda ()
                                 (interactive)
                                 (scroll-up-command 1)))
  (global-set-key (kbd "M-p") '(lambda ()
                                 (interactive)
                                 (scroll-down-command 1)))
  ;; Use by own split functions
  (global-set-key (kbd "C-x 2") 'my-split-window-below)
  (global-set-key (kbd "C-x 3") 'my-split-window-right))
#+END_SRC

** WindMove

Use windmove to move around multiple windows easily

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package windmove
  :config
  (windmove-default-keybindings))
#+END_SRC

** Y or N > Yes or No

Answer by =y= or =n= instead of =yes= of =no=.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package "subr"
  :ensure nil
  :config (fset 'yes-or-no-p 'y-or-n-p))
#+END_SRC

** Time mode

Display time on mode line.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package time
  :ensure nil
  :config (display-time-mode t))
#+END_SRC

** Simple

Display line numbers in mode line and undo keybinding.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package simple
  :ensure nil
  :config 
  (column-number-mode t)
  (global-set-key (kbd "C-z") 'advertised-undo))
#+END_SRC

** Display battery level

Display battery level inm mode line.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package battery
  :ensure nil
  :config (display-battery-mode t))
#+END_SRC

** Line numbers

Display line numbers every =prog-mode=.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package display-line-numbers
  :ensure nil
  :hook (prog-mode . display-line-numbers-mode))
#+END_SRC

** Files

Make sure that all backup files only exist in one place and always ask
before quitting Emacs.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package files
  :ensure nil
  :config 
  (setq backup-directory-alist '(("." . "~/.emacs.d/.backups")))
  (setq confirm-kill-emacs #'yes-or-no-p))
#+END_SRC

** Frame settings

Enable full frame on Emacs startup and set font.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package frame
  :ensure nil
  :config
  (add-hook 'after-init-hook 'toggle-frame-fullscreen)
  (set-frame-font "JetBrains Mono-13"))
#+END_SRC

** Winner mode

Allows to revert changes on the window configuration.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package winner
  :ensure nil
  :config (winner-mode t))
#+END_SRC

** Modern region behavior

Replace the active region when typing/yanking text, which is a little
handier than the default behaviour.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package delsel
  :ensure nil
  :config (delete-selection-mode +1))
#+END_SRC

** No scroll bar

I mean who likes this, really?

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package scroll-bar
  :ensure nil
  :config (scroll-bar-mode -1))
#+END_SRC

** Matching Parentheses

Show matching paren, quite useful for every languages especially Lisp!

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package paren
  :ensure nil
  :init (setq show-paren-delay 0)
  :config (show-paren-mode t))
#+END_SRC

** Ediff

Enter ediff with side-by-side buffers to better compare the
differences.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package ediff
  :ensure nil
  :config (setq ediff-split-window-function 'split-window-horizontally))
#+END_SRC

** Auto-pair

Auto close quote, parentheses, brackets, etc.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package elec-pair
  :ensure nil
  :hook (prog-mode . electric-pair-mode))
#+END_SRC

** Use ibuffer

Use ibuffer instead of default list buffer.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package "ibuffer"
  :config
  ;; Replace command to ibuffer
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  ;; Filter groups
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("dashboard"    (name . "\*dashboard\*"))
           ("clojure"      (or (mode . clojure-mode)
                               (name . "\*cider")
                               (name . "\*nrepl")))
           ("magit"        (name . "magit*"))
           ("emacs-config" (filename . ".emacs.d"))
           ("org"          (mode . org-mode))
           ("dired"        (mode . dired-mode)))))
  ;; Add hook
  (add-hook 'ibuffer-mode-hook
            '(lambda ()
               (ibuffer-switch-to-saved-filter-groups "default")))
  ;; Do not show groups that are empty
  (setq ibuffer-show-empty-filter-groups nil)
  ;; Do not prompt when deleting a new buffer
  (setq ibuffer-expert t))
#+END_SRC

** Compile

Set keybinding for the recompile command.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package compile
  :ensure nil
  :config
  (global-set-key (kbd "C-c C-k") 'recompile))
#+END_SRC

** Info

Change one =info-mode= keybinding to my scroll command.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package info
  :ensure nil
  :config
  (define-key Info-mode-map (kbd "M-n") '(lambda ()
                                           (interactive)
                                           (scroll-up-command 1))))
#+END_SRC

** JS

Set indent level for javascript/json files.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package js
  :ensure nil
  :config
  (setq js-indent-level 2))
#+END_SRC

* Third-party Packages

Here are all the packages I require from MELPA.

** Themes

Currently using the perfect Modus themes.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package modus-vivendi-theme
  :defer t
  :init
  (setq modus-vivendi-theme-distinct-org-blocks t
        modus-vivendi-theme-rainbow-headings t
        modus-vivendi-theme-slanted-constructs t
        modus-vivendi-theme-bold-constructs t
        modus-vivendi-theme-scale-headings t
        modus-vivendi-theme-scale-1 1.05
        modus-vivendi-theme-scale-2 1.1
        modus-vivendi-theme-scale-3 1.15
        modus-vivendi-theme-scale-4 1.2))
(use-package modus-operandi-theme
  :defer t
  :init
  (setq modus-operandi-theme-distinct-org-blocks t
        modus-operandi-theme-rainbow-headings t
        modus-operandi-theme-slanted-constructs t
        modus-operandi-theme-bold-constructs t
        modus-operandi-theme-scale-headings t
        modus-operandi-theme-scale-1 1.05
        modus-operandi-theme-scale-2 1.1
        modus-operandi-theme-scale-3 1.15
        modus-operandi-theme-scale-4 1.2))
#+END_SRC

** Diminish

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package diminish
  :defer t
  :after use-package)
#+END_SRC

** Ivy

I use Ivy as as a completion frontend, it integrates really well with
other super cool tools such as Swiper and Counsel.  There are other
choices for this such as Helm that I don't really like or the default
Ido mode that I should try one day.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package counsel
  :defer t
  :diminish ivy-mode counsel-mode
  :bind (("C-s" . swiper-isearch))
  :hook ((after-init . ivy-mode)
         (ivy-mode . counsel-mode))
  :init
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) "))
#+END_SRC

** Code Completion

I use =lsp-mode= as my completion tool.  Language Server Protocols
allows to use the most modern code completions since they use servers
as completion engines and =lsp-mode= is a great Emacs client for it.
I also use =company-mode= for the frontend completion.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package lsp-mode
  :defer t
  :init (setq lsp-keymap-prefix "C-c l")
  :hook ((python-mode . lsp)
         (go-mode . lsp)
         (ruby-mode . lsp)
         (typescript-mode . lsp)
         (web-mode . lsp))
  :commands lsp)

(use-package company-mode
  :defer t
  :diminish company-mode
  :init
  (setq company-selection-wrap-around t)
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay 0)
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous))
  :ensure company
  :hook ((after-init . global-company-mode)
          (company-mode . (lambda ()
                            (diminish 'company-mode)))))

(use-package company-lsp
  :defer t
  :after (company lsp)
  :init
  (push 'company-lsp company-backends)
  :commands company-lsp)
#+END_SRC

** Org Mode

I use org mode fo lots of things epacially to write this file.  It's
just really great!

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package org
  :defer t
  :diminish visual-line-mode auto-fill-function
  :preface
  (defun my-org-mode-hook ()
    (org-indent-mode 1)
    (visual-line-mode 1)
    (flyspell-mode 1)
    (auto-fill-mode 1))
  :hook ((org-mode . my-org-mode-hook)
         (org-indent-mode . (lambda ()
                              (diminish 'org-indent-mode)))
         (flyspell-mode . (lambda ()
                            (diminish 'flyspell-mode))))
  :config
  ;; Do not set headings face attributes if onve of the modus themes
  ;; is enabled since they already set this up.
  (set-face-attribute 'org-document-title nil :height 200)
  (unless (or (member 'modus-operandi custom-enabled-themes)
              (member 'modus-vivendi custom-enabled-themes))
    (set-face-attribute 'org-level-1        nil :height 160)
    (set-face-attribute 'org-level-2        nil :height 150)))

(use-package org-bullets 
  :defer t
  :hook (org-mode . org-bullets-mode))

(use-package toc-org
  :defer t
  :hook ((org-mode      . toc-org-mode)
         (markdown-mode . toc-org-mode)))
#+END_SRC

** Magit

Magit is an awesome git wrapper, everyone loves it, I love it and I
use it everyday.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package magit
  :defer t
  :bind ("C-x g" . 'magit-status))
#+END_SRC

** Flycheck

Flycheck linter.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package flycheck
  :diminish
  :config (global-flycheck-mode t))
#+END_SRC

** Projectile

Testing =Projectile= for project management.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package projectile
  :defer t
  :diminish
  :config
  (projectile-mode t)
  (setq projectile-completion-system 'ivy)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+END_SRC

** Neotree

Tree file structure for Emacs

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package neotree
  :defer t
  :config
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
  :bind (([f8] . neotree-toggle)))
#+END_SRC

** Which key

This is great to get a list of available commands while typing a key
chord.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode +1)
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.4))
#+END_SRC

** Undo tree

Handy features for undo/redo

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (global-undo-tree-mode))
#+END_SRC

** All the icons

Icons support in Emacs

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package all-the-icons
  :defer t)
#+END_SRC

** Dashboard

I just think it's neat!

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package dashboard
  :diminish page-break-lines-mode
  :config
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner 'official
        dashboard-items '((bookmarks . 10)
                          (projects . 5)
                          (recents . 5))
        dashboard-center-content t
        dashboard-set-heading-icons t
        dashboard-set-file-icons    t
        dashboard-banner-logo-title "Welcome to He-Macs!"))
#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode t))
#+END_SRC

** Clojure

*** Clojure mode

Install =clojure-mode= for editing.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package clojure-mode
  :defer t)
#+END_SRC

*** CIDER

Install =CIDER= for REPL support and other intractive features.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package cider
  :defer t)
#+END_SRC

** Typescript

I use typescript mode instead of tide since I am already using lsp as
a completion engine.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package typescript-mode
  :defer t
  :config
  (setq typescript-indent-level 2))
#+END_SRC

** Docker

To provide support fo docker I use =docker-mode= which is a wrapper
for the Docker CLI and =dockerfile-mode= which allows syntax
highlighting for Dockerfiles.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package docker
  :defer t
  :bind ("C-c d" . docker))

(use-package dockerfile-mode)
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package yaml-mode
  :defer t)
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package go-mode
  :defer t
  :config
  (defun lsp-go-install-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))
  (add-hook 'go-mode-hook #'lsp-go-install-save-hooks))
#+END_SRC

* Personal Packages

This part is about configuring packages that are not part of GNU Emacs
but written by me.  I chose not to upload them on MELPA since similar
version of thos packages already exists, I just didn't like them :)

** [[https://github.com/hmatheisen/new-term][New Term]]

This package allows to toggle a small terminal window on the bottom of
the screen.  It has a few other features like making it bigger or
smaller and quitting by closing the shell process and killing the
window.  It is somewhat similar to what you would find in more modern
editors such as VS Code.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package new-term
  :preface
  (defun my-new-term-hook ()
    (define-key term-raw-map (kbd "C-c <up>") 'bigger-term-window)
    (define-key term-raw-map (kbd "C-c <down>") 'smaller-term-window)
    (define-key term-raw-map (kbd "C-c q") 'quit-term))
  :ensure nil
  :init
  (setq new-shell "/usr/local/bin/bash")
  (global-set-key (kbd "C-x t") 'toggle-term-window)
  (add-hook 'term-mode-hook 'my-new-term-hook))
#+END_SRC

** [[https://github.com/hmatheisen/theme-switcher][Theme Switcher]]

This allows me to configure a theme for the day and a theme for the
night that automatically switches at given time.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package theme-switcher
  :ensure nil
  :init
  (setq day-hour 09)
  (setq night-hour 16)
  (setq day-theme 'modus-operandi)
  (setq night-theme 'modus-vivendi))
#+END_SRC

* Closing files

** =init.el=

#+BEGIN_SRC emacs-lisp :tangle init.el
;;; init.el ends here
#+END_SRC

